// Generated by CoffeeScript 2.0.0-beta8
void function () {
  var AMD_WRAPPER, amdWrap, ANONYMOUS_AMD_WRAPPER, canonicalise, esprima, exportAs, IIFE_WRAPPER, PRELUDE, PRELUDE_NODE, wrapFile;
  esprima = require('esprima');
  canonicalise = require('./canonicalise');
  PRELUDE_NODE = "\nvar process = function(){\n  var cwd = '/';\n  return {\n    title: 'browser',\n    version: '" + process.version + "',\n    browser: true,\n    env: {},\n    argv: [],\n    nextTick: global.setImmediate || function(fn){ setTimeout(fn, 0); },\n    cwd: function(){ return cwd; },\n    chdir: function(dir){ cwd = dir; }\n  };\n}();";
  PRELUDE = "function require(file, parentModule){\n  if({}.hasOwnProperty.call(require.cache, file))\n    return require.cache[file];\n\n  var resolved = require.resolve(file);\n  if(!resolved) throw new Error('Failed to resolve module ' + file);\n\n  var module$ = {\n    id: file,\n    require: require,\n    filename: file,\n    exports: {},\n    loaded: false,\n    parent: parentModule,\n    children: []\n  };\n  if(parentModule) parentModule.children.push(module$);\n  var dirname = file.slice(0, file.lastIndexOf('/') + 1);\n\n  require.cache[file] = module$.exports;\n  resolved.call(module$.exports, module$, module$.exports, dirname, file);\n  module$.loaded = true;\n  return require.cache[file] = module$.exports;\n}\n\nrequire.modules = {};\nrequire.cache = {};\n\nrequire.resolve = function(file){\n  return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;\n};\nrequire.define = function(file, fn){ require.modules[file] = fn; };";
  wrapFile = function (name, program) {
    var wrapper, wrapperProgram;
    wrapperProgram = esprima.parse('require.define(0, function(module, exports, __dirname, __filename){});');
    wrapper = wrapperProgram.body[0];
    wrapper.expression['arguments'][0] = {
      type: 'Literal',
      value: name
    };
    wrapper.expression['arguments'][1].body.body = program.body;
    return wrapper;
  };
  ANONYMOUS_AMD_WRAPPER = "(function(exported) {\n  if (typeof define === 'function' && define.amd)\n    define([], function() { return exported; });\n  if (typeof exports === 'object')\n    module.exports = exported;\n}(_));";
  AMD_WRAPPER = "(function(exported) {\n  if (typeof define === 'function' && define.amd)\n    define(_, [], function() { return exported; });\n  if (typeof exports === 'object')\n    module.exports = exported;\n  else\n    _;\n}(_));";
  amdWrap = function (maybeExport, requireEntryPoint) {
    var wrapper;
    wrapper = esprima.parse(null != maybeExport ? AMD_WRAPPER : ANONYMOUS_AMD_WRAPPER);
    wrapper.body[0].expression['arguments'][0] = requireEntryPoint;
    if (null != maybeExport) {
      wrapper.body[0].expression.callee.body.body[1].alternate.expression = exportAs(maybeExport, wrapper.body[0].expression.callee.params[0]);
      wrapper.body[0].expression.callee.body.body[0].consequent.expression['arguments'][0] = {
        type: 'Literal',
        value: maybeExport
      };
    }
    return wrapper;
  };
  IIFE_WRAPPER = '(function(global){ /* ... */ }).call(this, this);';
  exportAs = function (exportString, requireEntryPoint) {
    var exportExpression;
    exportExpression = esprima.parse(exportString).body[0].expression;
    return {
      type: 'AssignmentExpression',
      operator: '=',
      right: requireEntryPoint,
      left: exportExpression.type === 'Identifier' ? {
        type: 'MemberExpression',
        computed: false,
        object: {
          type: 'Identifier',
          name: 'global'
        },
        property: {
          type: 'Identifier',
          name: exportExpression.name
        }
      } : exportExpression
    };
  };
  module.exports = function (processed, entryPoint, root, options) {
    var ast, filename, iife, prelude, program, requireEntryPoint;
    prelude = (null != options.node ? options.node : true) ? '' + PRELUDE + '\n' + PRELUDE_NODE : PRELUDE;
    program = esprima.parse(prelude);
    for (filename in processed) {
      if (!isOwn$(processed, filename))
        continue;
      ast = processed[filename].ast;
      program.body.push(wrapFile(ast.loc.source, ast));
    }
    requireEntryPoint = {
      type: 'CallExpression',
      callee: {
        type: 'Identifier',
        name: 'require'
      },
      'arguments': [{
          type: 'Literal',
          value: canonicalise(root, entryPoint)
        }]
    };
    if (options.amd) {
      program.body.push(amdWrap(options['export'], requireEntryPoint));
    } else {
      program.body.push({
        type: 'ExpressionStatement',
        expression: null != options['export'] ? exportAs(options['export'], requireEntryPoint) : requireEntryPoint
      });
    }
    iife = esprima.parse(IIFE_WRAPPER);
    iife.body[0].expression.callee.object.body.body = program.body;
    iife.leadingComments = [{
        type: 'Line',
        value: ' Generated by CommonJS Everywhere ' + require('../package.json').version
      }];
    return iife;
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
